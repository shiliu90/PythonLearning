# 正则表达式的规则定义
import re

# 普通字符

# vars = 'iloveyou'
#
# reg = 'love'
# res = re.search(reg,vars).group()
# print(res)

# 转义字符 \w \W \d \D \s \S ...
varstr = 'a2$_ilove5	21you'

reg = '\w' # 代表 单个 字母、数字、下划线
reg = '\W' # 代表 单个的 非 字母、数字、下划线
reg = '\d' # 代表 单个的 数字
reg = '\D' # 代表 单个的 非数字
reg = '\s' # 代表 单个的 空格符或制表符
reg = '\S' # 代表 单个的 非 空格符或制表符
reg = '\w\w\w\w\d' # 组合使用


# 特殊字符 . * + ? {} [] () ^ $
varstr = 'hello WORLD  iloveyou5211imissyou'

reg = '.'    # . 点 代表 单个的 任意字符 除了换行符之外
reg = '\w*'  # * 代表匹配次数  任意次数
reg = '\w+'  # + 代表匹配次数  至少要求匹配一次
reg = '\w+?' # ? 拒绝贪婪，就是前面的匹配规则只要达成则返回
reg = '\w*?'
reg = '\w{5}' # {} 代表匹配次数，{4} 一个数字时，表示必须匹配的次数
reg = '\w{2,4}' # {} 代表匹配次数，{2,5} 两个数字时，表示必须匹配的区间次数
reg = '[A-Z,a-z,0-9,_]' # [] 代表字符的范围 [A-Z,a-z,0-9,_] == \w
reg = '\w+(\d{4})(\w+)'  # () 代表子组，括号中的表达式首先作为整个正则的一部分，另外会把符合小括号中的内容单独提取一份

varstr = '17610105211'
# 定义一个匹配手机号的正则表达式
reg = '^1\d{10}$' # ^ 代表开头  $ 代表结尾



# res = re.search(reg,varstr)
# print(res.group())
# print(res.groups())

# 正则模式 re.I 不区分大小写
vars = 'iLOVEyou'

reg = '[a-z]{5,10}'
res = re.search(reg,vars,re.I)
print(res)

'''
# 特点： 
    如果使用*号，那么在匹配的开始处如果符合要求，
    则按照规则一直向后匹配，直到不符合匹配规则结束并把前面符合的数据返回
    
    如果在匹配的开始处就不符合要求，则直接返回，匹配到的次数为0
'''


# 练习题：
# 1。定义一个正则表达式，来验证邮箱是否正确
# 2。完善 手机号的 正则表达式
# 3。定义一个 匹配 IP 的正则表达式 192.168.1.1  255.255.255.0



